/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/models/models/door.gltf --t --o components/door/door.tsx 
*/

import React, { useEffect, useMemo, useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { ANIMATION_SPEED, GLTFResult, Scale } from './type';
import { useDoorStore } from '../store';
import {
  Group,
  Mesh,
  MeshStandardMaterial,
  Object3DEventMap,
  TextureLoader,
} from 'three';
import { useFrame, useLoader } from '@react-three/fiber';
import { HoneyComb } from './honeycomb';
import { DoorLeaf } from './door-leaf';
import { Hinge } from './hinge';
import { Frame } from './frame';
import { Architrave } from './architrave';
import variants from '../../../public/variants.json';

// import { Scale } from 'lucide-react';

interface LoadMaterialProps {
  variantCode: string;
}

function LoadMaterial({ variantCode }: LoadMaterialProps) {
  const [fallbackMaterial] = useState(
    () => new MeshStandardMaterial({ color: 'gray' })
  );

  const textureUrl = variants.find(
    (variant) => variant.data.code === variantCode
  )?.data.file.url;

  console.log('textureUrl', textureUrl);

  // if (!textureUrl) {
  //   return fallbackMaterial;
  // }
  const texture = useLoader(
    TextureLoader,
    '/models/textures/taco-hpl.webp'

    // '/nextImageExportOptimizer/7280703542552234-opt-3840.WEBP'
  );

  const material = useMemo(
    () =>
      texture ? new MeshStandardMaterial({ map: texture }) : fallbackMaterial,
    [texture, fallbackMaterial]
  );

  return material;
}

export function Model(props: JSX.IntrinsicElements['group']) {
  const result = useGLTF('/models/door.gltf') as GLTFResult;
  const { nodes, materials } = result;
  const storage = useDoorStore();
  const DOOR_SCALE: Scale = {
    width: storage.size.width / 83,
    height: storage.size.height / 210,
  };

  const honeyCombMaterial = materials.mdf;
  const customMaterial = LoadMaterial({
    variantCode: storage.finishingVariant?.name ?? '',
  });
  const getDoorFinishingMaterial = () => {
    if (storage.finishing?.name === 'HPL Std') {
      return materials.tacoSheet;
    }
    if (storage.finishing?.name === 'PVC Sheet') {
      return materials.tacoHpl;
    }
    return honeyCombMaterial;
  };
  const doorFinishingMaterial = getDoorFinishingMaterial();

  const doorGroupRef = React.useRef<Group<Object3DEventMap> | null>(null);
  const handleRef = React.useRef<Mesh | null>(null);
  const keyRef = React.useRef<Mesh | null>(null);
  const doorLockRef = React.useRef<Mesh | null>(null);

  useFrame(() => {
    if (doorGroupRef.current) {
      const y =
        DOOR_SCALE.height < 1 ? DOOR_SCALE.height : DOOR_SCALE.height * 1.005;

      doorGroupRef.current.scale.lerp(
        { x: DOOR_SCALE.width, y: y, z: 1 },
        ANIMATION_SPEED
      );
    }
    if (doorLockRef.current) {
      doorLockRef.current.position.lerp(
        {
          x: -0.019 * (DOOR_SCALE.width - 1),
          y: 1.1 * (DOOR_SCALE.height - 1),
          z: 0,
        },
        ANIMATION_SPEED
      );
    }
    if (handleRef.current) {
      handleRef.current.position.lerp(
        {
          x: 0.065 * (DOOR_SCALE.width - 1),
          y: 1.1 * (DOOR_SCALE.height - 1),
          z: 0,
        },
        ANIMATION_SPEED
      );
    }
    if (keyRef.current) {
      keyRef.current.position.lerp(
        {
          x: 0.065 * (DOOR_SCALE.width - 1),
          y: 1 * (DOOR_SCALE.height - 1),
          z: 0,
        },
        ANIMATION_SPEED
      );
    }
  });

  return (
    <group {...props} dispose={null}>
      <group ref={doorGroupRef}>
        {storage.finishing ? (
          <DoorLeaf
            gltfResult={result}
            name={storage.groove?.name ?? ''}
            material={customMaterial}
          />
        ) : (
          <HoneyComb gltfResult={result} material={honeyCombMaterial} />
        )}
      </group>
      {storage.hinge?.isAdded && (
        <Hinge gltfResult={result} DOOR_SCALE={DOOR_SCALE} />
      )}
      <Frame
        gltfResult={result}
        material={doorFinishingMaterial}
        DOOR_SCALE={DOOR_SCALE}
      />
      <Architrave
        gltfResult={result}
        material={doorFinishingMaterial}
        DOOR_SCALE={DOOR_SCALE}
      />
      {storage.key?.isAdded && (
        <mesh
          geometry={nodes.DoorKey.geometry}
          material={materials.chrome2}
          ref={keyRef}
        />
      )}
      {storage.handle?.isAdded && (
        <mesh
          geometry={nodes.DoorHandle.geometry}
          material={materials.chrome2}
          ref={handleRef}
        />
      )}
      {storage.cylinder?.isAdded && (
        <mesh
          geometry={nodes.DoorLock.geometry}
          material={materials.chrome2}
          ref={doorLockRef}
        />
      )}
    </group>
  );
}

useGLTF.preload('/models/door.gltf');
